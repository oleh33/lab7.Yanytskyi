# Lab 7 — Обробка IO/мережевих помилок та патерн Retry

## Мета роботи
Ознайомитися з обробкою винятків вводу/виводу та мережевих помилок у C#.  
Навчитися використовувати конструкції try-catch-finally, а також реалізувати патерн Retry з експоненційною затримкою.

## Опис проєкту
Проєкт містить реалізацію трьох основних компонентів, що демонструють роботу з винятками та повторними спробами:

### FileProcessor
Імітує роботу з файлами.  
Метод `GetNotificationPayload` перші три спроби генерує `IOException`, після чого повертає коректний payload.

### NetworkClient
Імітує відправку мережевого запиту.  
Метод `SendPushNotification` перші дві спроби викидає `HttpRequestException`, а далі завершується успішно.

### RetryHelper
Універсальний клас для виконання операцій з повторними спробами.  
Метод `ExecuteWithRetry<T>` підтримує:
- операцію у вигляді делегата `Func<T>`,
- налаштовувану кількість спроб,
- початкову затримку,
- експоненційне збільшення затримки між спробами,
- вибіркову обробку винятків через `shouldRetry`.

## Демонстрація роботи
У методі `Main` реалізовано сценарій "Відправка push-сповіщення", який включає:
1. Отримання payload за допомогою `FileProcessor` з повторними спробами.
2. Відправлення push-сповіщення через `NetworkClient` із застосуванням Retry.
3. Логування номеру спроби та причини невдачі.
4. Використання делегата `shouldRetry` для контролю над тим, які винятки підлягають повтору.

## Як запустити
1. Відкрити проєкт у Visual Studio або Rider.
2. Запустити виконання програми.
3. У консолі буде продемонстровано всі спроби виконання та фінальний успішний результат.

## Контрольні питання
1. Які типи винятків часто виникають при роботі з файлами та мережею?  
2. У чому полягає суть патерну Retry і коли його варто використовувати?  
3. Як працює експоненційна затримка між повторними спробами?  
4. Для чого використовується делегат `shouldRetry` у класі `RetryHelper`?
